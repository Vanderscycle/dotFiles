#+title: Terraform
#+author:    Henri Vandersleyen
#+email:     henri-vandersleyen@protonmail.com

* Terraform Basic
** Table of Content
Terraform is used as an extensible and powerful tool

** Basic structure
*** File

The basic file structure of a `.tf` file is as follow.
#+begin_src terraform
<block> <resource type> <resource name> {
# arguments
    key1 = value1
    key2 = value2
}
#+end_src
Nomenclature

*** Folder

A simple project terraform folder structure:
#+begin_src terraform
.
└── tf/
    ├── versions.tf
    ├── variables.tf
    ├── provider.tf
    ├── droplets.tf
    ├── dns.tf
    ├── data-sources.tf
    └── external/
        └── name-generator.py
#+end_src


a more complex terraform folder structure:
#+begin_src terraform
.
└── tf/
├── modules/
│   ├── network/
│   │   ├── main.tf
│   │   ├── dns.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   └── spaces/
│       ├── main.tf
│       ├── outputs.tf
│       └── variables.tf
└── applications/
├── backend-app/
│   ├── env/
│   │   ├── dev.tfvars
│   │   ├── staging.tfvars
│   │   ├── qa.tfvars
│   │   └── production.tfvars
│   └── main.tf
└── frontend-app/
├── env/
│   ├── dev.tfvars
│   ├── staging.tfvars
│   ├── qa.tfvars
│   └── production.tfvars
└── main.tf
#+end_src

**** File explanation
- main.tf - call modules, locals, and data sources to create all resources
- variables.tf - contains declarations of variables used in main.tf
- outputs.tf - contains outputs from the resources created in main.tf
- versions.tf - contains version requirements for Terraform and providers
- resources.tf - ??
- providers.tf - version control for provides

** Basic Workflow
1. Create resources
2. `terraform init`
3. `terraform plan -out=output.tfplan`
4. `terraform apply output.tfplan`
   - idempotent config meaning that futher plan/apply will mirror
5. `terraform destroy` will destroy all ressources in the folder

When using terraform plan and apply, we want the have the exact configuration listed in the `main.tf`. This entails destroying ressources (e.g a change in file name)  to create new ones.

You should always `plan` before `applying` even if you are not required.
#+begin_src bash
terraform init
terraform plan -out=output.tfplan
#terraform apply output.tfplan
#+end_src

#+RESULTS:
** Debugging
1. `Terrafrom show` to show the resource state.
2. `Terraform output` to show defined `output.tf` values

** Terraform providers
When executing `terraform init` it will pull all of the listed terraform provides. There are several types of provides:
- Official (Terraform)
- Partner (e.g. heroku, digitalOcean)
- OSS (community)
`terraform init` is a safe command that can be run any number of times init.
Should the provider's version be specified (which you should) then populate the `provides.tf`

Each different providers will be downloaded upon `terraform init` inside `.terraform/plugins/`


** Input variables

Contend of a `variables.tf`
#+begin_src terraform
variable "byte_length" {
  default = 8
}
#+end_src

Contend of a `main.tf` in the same folder as `variables.tf`
#+begin_src terraform
resource "random_id" "server" {
  byte_length = var.byte_length
}
#+end_src

Current folder will look like this
#+begin_src
❯ ls
drwxr-xr-x    - henri 10 Mar 07:55 .terraform
.rw-r--r--  290 henri 11 Mar 22:05 main.tf
.rw-r--r-- 2.3k henri 10 Mar 07:57 output.tfplan
.rw-r--r-- 2.0k henri 11 Mar 21:19 terraform.tfstate
.rw-r--r--  141 henri 11 Mar 22:05 variables.tf
drwxr-xr-x    - henri 10 Mar 07:57 ~
#+end_src

**  Variable block

Recommended setup for variable definition

#+begin_src terraform
variable "file_permisson" {
  default = "0700"
  type = string
  description = "permissions associated with the file"
}
#+end_src

The only variable types are:

| Type   | Example        |
|--------+----------------|
| string | "hello mom"    |
| number | 1              |
| bool   | true/false     |
| any    | Default Value  |
| list   | ["cat", "dog"] |
| map    | pet1=cat       |
| object |                |
| tuple  |                |

Complex data type:
**** List
#+begin_src terraform
variable "file_permisson" {
  default = [ "0700" "777"]
  type = list(string)
  description = "list of allowed permissions"
}

resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = var.content
  file_permission = var.file_permission[0]
}
#+end_src

the `list` type support greater accuracy with list(string/number)

**** Map
#+begin_src terraform
variable "file_permisson" {
  default = {
    "secret" = "700"
    "admin"  "777"
    }
  type = map(string)
  description = "Map of allowed permissions"
}

resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = var.content
  file_permission = var.file_permission["admin"]
}
#+end_src


the `map` type support greater accuracy with map(string/number)

**** 
A set is a list that cannot have a duplicate element. Same with subtyples `set(string/number)`

**** Object
#+begin_src terraform
variable "bob" {
  default = {
    name = "bob"
    color = "no importance"
    age = 33
    food = ["humous" , "feta"]
    permission = "777"

    }
  type = object({
  name = string
  color = string
  age = number
  food = list(string)
  permission = string})
  description = "Object of employee type privileges and info"
}

resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = var.content
  file_permission = var.bob["permission"]
}
#+end_src

**** Tuples
#+begin_src terraform
variable "bob" {
  default = [ 43, "777" , true]
  type = tuple([number, string, bool])
  description = "Object of employee type privileges and info"
}

resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = var.content
  file_permission = var.bob[1]
}
#+end_src

**** Variable definition
Similar to lists but can be of different variable types.
`default`, `type` and `description` greatly enhance the code longevity. If no default is supplied, `terraform apply` will ask you for the variable's value. Otherwise you can supply them in the cli or pass them as an export var `export TF_VAR_FILENAME="/root/pets.txt"`
#+begin_src bash
terrafrom apply -var "filename=/root/pets.txt" -var "content=We love Pets" ...
 #+end_src

An alternative is to store them inside a `terraform.tfvars` or `terraform.tfvars.json`, `*.auto.tfvars`, `*.auto.tfvars.json` which will be automatically loaded. Any other name will require an extra flag for the cli `-var-file variables.tfvars`
#+begin_src tfvars
filename = "/root/pets.txt"
content = "We love pets!"
#+end_src

Order for precedence: (lowest to highest)
1. Env vars `TF_VAR`
2. Terraform.tfvars
3. *.auto.tfvars (and other)
4. cli

** Resource Attributes

How to feed the output of one ressource into another (e.g. create dependencies)
#+begin_src terraform
resource "local_file" "pet" {
  filename = "${path.module}/pet.txt"
  content = "My favorite foo is ${random_pet.my-per.id}" # the `$` is an main
}
resource "random_pet" "my-pet" {}
#+end_src
The required pattern is `resource_type.resource_name.attribute`. If unusre what attribute, then run `terraform plan`
To inspect the attributes values use `terraform show`

** Resource dependencies
Terraform is smart enough to figure out the `implicit dependencies` see above example. However is can be `explicit` uesfull when a resource is inderectly dependent on another one.
#+begin_src terraform
resource "local_file" "pet" {
  filename = "${path.module}/pet.txt"
  content = "My favorite foo is big bob"

  depends_on = [
    random_pet.my-pet
  ]
}
resource "random_pet" "my-pet" {}
#+end_src

** Output variables
To define desired output to get something more than just the resource's `id`. `output.tf` is usefull to feed data into let's say ansible.
#+begin_src options
output "<variable_name>" {
value = "<variable_value>"
<arguments>
}
#+end_src

To show the output's value run `terraform output` or `terraform output <variable_name`

* Terraform State

Upon running `terrafrom apply` terraform will create `terraform.tfstate` which managed the infrastructure state. EXTREMELY IMPORTANT for cloud ressources.
You can save the `terraform.tfstate` in an s3 bucket so that the latest version is accessible to the team.
We also cannot disable the state of terrafrom.
Be warned that the statefile may contains plaintext sensitive configuration. Best practice is to store it in remote state backends (e.g. s3 bucket, Terraform Cloud)
Never manually change the tfstate file

* Working with Terrraform

** Other usefull commands
- `terraform validate` instead of using `plan/apply` to check the state. Essentially lint.
    Only validates resources block and the argument syntax, but not the input values
- `terraform show -json` shows the tfstate
- `terraform providers` show all used plugins for resources
- `terraform fmt` formats the tf files
- `terraform output` output all of `outputs.tf` vars
- `terrafrom refresh` automatically ran by `plan/apply`
- `terrafrom graph` shows the terraform dependencies in a graph format. Requires `graphviz` or similar

** Mutable vs immutable infrastructure + lifecycle rules
Mutable IoC: able to change the version of the infrastructure
Immutable: destroy, then creates a new resource (default)

You can modify terraform behavior using the `lifecycle` key/value
#+begin_src terraform
variable "file_permisson" {
  default = "0700"
  type = string
  description = "permissions associated with the file"

}
resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = "bar"
  file_permission = var.file_permission

  lifecycle {
    create_before_destroy = true
    prevent_destroy = true # e.g. don't drop db
    ignore_changes = [
      content, filename # has to declaratively list what must be changed
    ]
  }
}
#+end_src

For example you may want to prevent certain fields from being changed

** Data sources
Because we can use other tools such as ansible, puppet, saltstack, or do it manually we need a way to read resources that are outside of terraform control. We solve this using datasources.
The datasource block is similar to a resource block.
#+begin_src terraform
data "local_file" "dog" {
  filename = "/root/dog.txt"
}
# To reference the data we use `data.resource_type.ressource_name.attribute`
resource "local_file" "foo" {
  filename = "${path.module}/foo.txt"
  content = data.local_file.dog.content
  file_permission = var.file_permission
}
#+end_src

When reading the documentation you can see its usage between `Resources` and `Data Sources`

** Meta-arguments
- `depends_on`
- `lifecycle`
- `count`
- `for_each`

[[https://developer.hashicorp.com/terraform/language/functions][terraform builtin]] functions documentation
*** Count
#+begin_src terraform

resource "local_file" "pets" {
  filename = var.filename[count.index]
  count = length(var.filename) #buildin functions
}
variable "filename" {
  type = list(string)
  default = [
  "/root/pets.txt",
  "/root/cats.txt",
  "/root/dogo.txt"
  ]
  description = "list of required files"
}
#+end_src

*** For each
Only works with `maps` or a `set` or a list to set convertion using the builting function `toset(var.name)`
#+begin_src terraform

resource "local_file" "pets" {
  filename = var.filename[count.index]
  for_each = toset(var.filename)
}

variable "filename" {
  type = list(string)
  default = [
  "/root/pets.txt",
  "/root/cats.txt",
  "/root/dogo.txt"
  ]
  description = "list of required files"
}
output "pets" {
    values = local_file.pets
}
#+end_src

** version constraints
So that you may track version dependencies

#+begin_src terraform
terraform {
  required_providers {
    local = {
      source = "hashicorp/local"
      version = "2.3.0"
    }
  }
}
resource "local_file" "pets" {
  filename = var.filename[count.index]
  for_each = toset(var.filename)
}
#+end_src

Do not use this version `"!=2.0.0"`
Use version up to`"< 2.0.0"`
Use version at least`"> 2.0.0"`
Only use this version or its `semver` increment `"~> 1.2"` so 1.2 to 1.9
    Can also use greater accuracy `~> 1.2.0` so 1.2.0 to 1.2.9
you can also use them in combinations `"> 1.2.0, < 2.0.0, != 1.4.0"`
